package mytoy
package main

/*
================================================================================
第三步：引入上下文（Context）
================================================================================

问题：
1. 每个handler都需要处理 http.ResponseWriter 和 *http.Request，很繁琐
2. 常见操作（返回JSON、HTML、获取参数）需要重复代码
3. 代码不够优雅

解决：封装一个 Context 结构体，提供便捷方法

Context 的作用：
- 封装请求和响应




















































































































































































































































*/你的 day2-http-context 项目就是这个阶段！✅ 这是Gin、Echo、Fiber等主流框架的核心设计✅ 代码更简洁、更易读、更易维护✅ Context封装了请求和响应的常用操作总结：是不是简洁多了？这就是Context的价值！	}		c.String(200, "Hello %s", name)		name := c.Query("name")	func handler(c *Context) {step3 (使用Context):	}		fmt.Fprintf(w, "Hello %s", name)		w.Header().Set("Content-Type", "text/plain")		name := r.URL.Query().Get("name")	func handler(w http.ResponseWriter, r *http.Request) {step2 (原始方式):对比 step2 和 step3：/*}	log.Fatal(http.ListenAndServe(":8005", router))		log.Println("  curl -X POST http://localhost:8005/login -d 'username=admin&password=123456'")	log.Println("  curl http://localhost:8005/api/user")	log.Println("  curl http://localhost:8005/hello?name=李四")	log.Println("  curl http://localhost:8005/")	log.Println("试试这些命令:")	log.Println("服务器启动在 http://localhost:8005")		router.POST("/login", loginHandlerV2)	router.GET("/api/user", userHandlerV2)	router.GET("/hello", helloHandlerV2)	router.GET("/", indexHandlerV2)	// 注册路由 - 看看代码多么简洁！		router := NewRouterV2()func main() {}	})		"status":   "登录成功",		"password": password,		"username": username,	c.JSON(http.StatusOK, map[string]string{	// 返回JSON		password := c.PostForm("password")	username := c.PostForm("username")	// 获取POST参数超级简单！func loginHandlerV2(c *Context) {}	c.JSON(http.StatusOK, user)	}		Email:    "zhangsan@example.com",		Age:      25,		Username: "张三",	user := User{	// 返回JSON超级简单！func userHandlerV2(c *Context) {}	Email    string `json:"email"`	Age      int    `json:"age"`	Username string `json:"username"`type User struct {// 定义一个数据结构}	c.String(http.StatusOK, "你好, %s! 你访问的路径是: %s\n", name, c.Path)	// 返回文本也很简单！	}		name = "访客"	if name == "" {	name := c.Query("name")	// 获取参数超级简单！func helloHandlerV2(c *Context) {}	`)		</ul>			<li><a href="/api/user">获取用户JSON</a></li>			<li><a href="/hello?name=张三">问候张三</a></li>		<ul>		<p>这是使用Context的版本</p>		<h1>欢迎来到首页</h1>	c.HTML(http.StatusOK, `func indexHandlerV2(c *Context) {// ============================================================================// 处理函数 - 现在使用 Context，代码更简洁！// ============================================================================}	}		c.String(http.StatusNotFound, "404 NOT FOUND: %s\n", req.URL.Path)	} else {		handler(c)  // 使用Context调用处理函数	if handler, ok := r.handlers[key]; ok {	key := req.Method + "-" + req.URL.Path	// 查找路由		c := NewContext(w, req)	// 创建Contextfunc (r *RouterV2) ServeHTTP(w http.ResponseWriter, req *http.Request) {}	log.Printf("注册路由: %s", key)	r.handlers[key] = handler	key := method + "-" + pathfunc (r *RouterV2) addRoute(method, path string, handler HandlerFunc) {}	r.addRoute("POST", path, handler)func (r *RouterV2) POST(path string, handler HandlerFunc) {}	r.addRoute("GET", path, handler)func (r *RouterV2) GET(path string, handler HandlerFunc) {}	}		handlers: make(map[string]HandlerFunc),	return &RouterV2{func NewRouterV2() *RouterV2 {}	handlers map[string]HandlerFunctype RouterV2 struct {// ============================================================================// RouterV2 - 使用Context的路由器// ============================================================================type HandlerFunc func(*Context)// ============================================================================// HandlerFunc - 使用Context的处理函数类型// ============================================================================}	c.Writer.Write(data)	c.Status(code)func (c *Context) Data(code int, data []byte) {// 返回原始数据}	fmt.Fprint(c.Writer, html)	c.Status(code)	c.SetHeader("Content-Type", "text/html; charset=utf-8")func (c *Context) HTML(code int, html string) {// 返回HTML}	}		http.Error(c.Writer, err.Error(), 500)	if err := encoder.Encode(obj); err != nil {	encoder := json.NewEncoder(c.Writer)	c.Status(code)	c.SetHeader("Content-Type", "application/json")func (c *Context) JSON(code int, obj interface{}) {// 返回JSON}	fmt.Fprintf(c.Writer, format, values...)	c.Status(code)	c.SetHeader("Content-Type", "text/plain; charset=utf-8")func (c *Context) String(code int, format string, values ...interface{}) {// 返回纯文本}	c.Writer.Header().Set(key, value)func (c *Context) SetHeader(key, value string) {// 设置响应头}	c.Writer.WriteHeader(code)	c.StatusCode = codefunc (c *Context) Status(code int) {// 设置状态码// ----------------------------------------------------------------------------// 响应相关方法// ----------------------------------------------------------------------------}	return c.Request.FormValue(key)func (c *Context) PostForm(key string) string {// 获取表单参数：POST请求的body}	return c.Request.URL.Query().Get(key)func (c *Context) Query(key string) string {// 获取URL参数：/hello?name=张三// ----------------------------------------------------------------------------// 请求相关方法// ----------------------------------------------------------------------------}	}		Method:  r.Method,		Path:    r.URL.Path,		Request: r,		Writer:  w,	return &Context{func NewContext(w http.ResponseWriter, r *http.Request) *Context {// 创建Context}	StatusCode int	// 响应信息		Method string	Path   string	// 请求信息（方便访问）		Request *http.Request	Writer  http.ResponseWriter	// 原始对象type Context struct {// ============================================================================// Context - 上下文对象，封装请求和响应// ============================================================================)	"net/http"	"log"	"fmt"	"encoding/json"import (*/- 这是所有现代Web框架的核心设计！- 提供便捷的响应方法（JSON、HTML、String等）- 提供便捷的参数获取方法