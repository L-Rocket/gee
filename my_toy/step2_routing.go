package mytoy
package main

/*
================================================================================
第二步：理解路由（Routing）
================================================================================

问题：在step1中，无论访问什么路径，都是同一个handler处理
解决：我们需要根据不同的路径，调用不同的处理函数


































































































































*/下一步：我们需要封装一个"上下文（Context）"来简化这些操作- 获取参数（Query、PostForm）代码重复- 返回JSON、HTML等格式需要手动设置Content-Type- 每次都要写 http.ResponseWriter 和 *http.Request 很繁琐问题：4. 这就是所有Web框架路由功能的核心原理！3. ServeHTTP 方法负责查找并执行对应的处理函数2. 它维护一个 map 来存储 路径→处理函数 的映射1. 路由器是一个实现了 http.Handler 接口的结构体总结：/*}	log.Fatal(http.ListenAndServe(":8004", router))		log.Println("  curl http://localhost:8004/notfound  # 测试404")	log.Println("  curl -X POST http://localhost:8004/login -d 'username=admin&password=123456'")	log.Println("  curl http://localhost:8004/about")	log.Println("  curl http://localhost:8004/hello?name=张三")	log.Println("  curl http://localhost:8004/")	log.Println("试试这些命令:")	log.Println("服务器启动在 http://localhost:8004")	// 启动服务器		router.POST("/login", loginHandler)	router.GET("/about", aboutHandler)	router.GET("/hello", helloHandler)	router.GET("/", indexHandler)	// 注册路由		router := NewRouter()	// 创建路由器func main() {}	fmt.Fprintf(w, "密码: %s\n", password)	fmt.Fprintf(w, "用户名: %s\n", username)	fmt.Fprintf(w, "登录信息:\n")		password := r.FormValue("password")	username := r.FormValue("username")	r.ParseForm()	// 解析表单数据func loginHandler(w http.ResponseWriter, r *http.Request) {}	fmt.Fprintf(w, "这是一个学习Go Web框架的项目\n")	fmt.Fprintf(w, "关于我们\n")func aboutHandler(w http.ResponseWriter, r *http.Request) {}	fmt.Fprintf(w, "你好, %s！\n", name)	}		name = "访客"	if name == "" {	name := r.URL.Query().Get("name")	// 获取URL参数：/hello?name=张三func helloHandler(w http.ResponseWriter, r *http.Request) {}	fmt.Fprintf(w, "当前时间: 2026-01-23\n")	fmt.Fprintf(w, "欢迎来到首页！\n")func indexHandler(w http.ResponseWriter, r *http.Request) {// ============================================================================// 定义各种处理函数// ============================================================================}	}		http.NotFound(w, req)		// 没找到，返回404	} else {		handler(w, req)  // 找到了，执行处理函数	if handler, ok := r.handlers[key]; ok {	// 在map中查找对应的处理函数		key := req.Method + "-" + req.URL.Path	// 构造查找的keyfunc (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {// 实现 http.Handler 接口}	log.Printf("注册路由: %s", key)	r.handlers[key] = handler	key := method + "-" + pathfunc (r *Router) addRoute(method, path string, handler http.HandlerFunc) {// 内部方法：添加路由}	r.addRoute("POST", path, handler)func (r *Router) POST(path string, handler http.HandlerFunc) {// 注册POST路由}	r.addRoute("GET", path, handler)func (r *Router) GET(path string, handler http.HandlerFunc) {// 注册GET路由}	}		handlers: make(map[string]http.HandlerFunc),	return &Router{func NewRouter() *Router {}	handlers map[string]http.HandlerFunc	// 存储路由映射：key = "方法-路径", value = 处理函数type Router struct {// ============================================================================// 手动实现一个简单的路由器// ============================================================================)	"net/http"	"log"	"fmt"import (*/- 例如：map["GET-/hello"] = helloHandler- 一个 map：key = "方法-路径", value = 处理函数路由的本质：这就是"路由"的核心功能：将 URL路径 + HTTP方法 映射到 处理函数